w

> 시스템을 깨끗히 구현하자! 깨끗하지 못한 아키텍처는 도메인 논리를 흐리며 기민성을 떨어뜨린다. 기민성이 떨어지면 생산성이 낮아져 TDD가 제공하는 장점이 사라진다. 모든 추상화 단계에서 의도를 명확하게 하자!

### 도시를 세운다면

- 도시가 돌아가는 이유는 적절한 추상화와 모듈화 덕분
  - 큰 그림을 이해하지 못하더라도 개인이 관리하는 구성 요소는 효율적으로 돌아감

### 시스템 제작과 시스템 사용을 분리하라

> 소프트웨어 시스템은 준비 과정과 런타임 로직을 분리해야 한다

- 관심사 분리(Seperation of concerns)는 소프트웨어 상에서 구조를 패턴, 역할, 기능 등을 각각 맞게 섹션 별로 분리해서 작성하는 것
  - 한 영역이 다른 영역과 격리되기 때문에 다른 영역에 영향을 주지 않고도 변경할 수 있다
  - 유지보수가 용이해진다
  - 변경이 지역화되므로 디버그, 문제 격리, 식별이 용이해지고 코드 중복이 줄어들어 코드 재사용이 증진
- 사용과 제작을 분리하는 3가지 방법: main 분리, 팩토리, 의존성 주입

#### main 분리

- 생성과 관련된 모든 코드는 main이나 main이 호출하는 모듈로 옮기고 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정
  - 어플리케이션은 객체가 생성되는 과정을 전혀 모름
  - main 함수에서 시스템에 필요한 객체를 생성 후 이를 애플리케이션에 넘김
    - 모든 의존성이 main -> 애플리케이션

#### 팩토리

- 객체 생성 시점을 애플리케이션이 결정할 필요가 있을 때 Abstract Factory 패턴을 사용하여 생성 코드를 감춤
  - OrderingProcessing 애플케이션은 객체 LineItem이 생성되는 구체적인 방법을 모름
- Absctract Factory: 추상 팩토리
  - 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴
  - 관련성 있는 객체를 일관성 있는 방식으로 생성하는 경우에 유용
  - AbstractFactory: 실제 팩토리 클래스의 공통 인터페이스
  - ConcreteFactory: 구체적인 팩토리 클래스로 AbstractFactory 클래스의 추상 메서드를 오버라이드함으로써 구체적인 제품을 생성
  - AbstractProduct: 제품의 공통 인터페이스
  - ConcreteProduct: 구체적인 팩토리 클래스에서 생성되는 구체적인 제품
- 모든 의존성이 main -> orderProcessing

#### 의존성 주입

- 제어 역전 기법을 의존성 관리에 적용한 메커니즘
  - 제어 역전 기법이란 한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 떠넘기는 것으로, 새로운 객체는 넘겨받은 책임만 맡으므로 SRP 만족시킴
- 의존성 관리의 관점에서 객체는 의존성 자체를 인스턴스로 만드는 책임을 지지 않는다(자신의 의존성을 직접 생성하지 않는다)
  - 대신 다른 전담 메커니즘에게 제어를 역전한다
- 진정한 의존성 주입은 클래스가 의존성을 해결하지 않는다
  - 대신 의존성을 주입하는 방법으로 설정자 메서드나 생성자 인수를 (혹은 둘 다) 제공
- DI(의존성 주입) 컨테이너는 필요한 객체의 인스턴스를 만든 후 생성자 인수나 설정자 메서드를 사용해 의존성 설정

### 확장

- TDD(테스트 주도 개발)과 리펙터링으로 얻어지는 깨끗한 코드는 코드 수준에서 시스템을 조정하고 확장하기 쉽게 만든다
- 관심사를 적절히 분리해 관리한다면 소프트웨어 아키텍처는 발전할 수 있다
- 횡단(cross-cutting) 관심사
  - (영속성과 같이) 다른 관심사에 영향을 미치는 aspect
  - AOP(관점 지향 프로그래밍)은 횡단 관심사항의 기능을 모듈화하여 중복을 최소화하면서, 핵심 관심사항에 집중하도록 하는 프로그래밍 기법
    - 모듈 구성 개념인 '관점' -> 특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 있게 바궈야 한다
![횡단 관심사](https://determined-floss-33d.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F4c9f0fc5-ba0e-4082-8912-f0c4990aef38%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2021-07-28_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.25.56.png?table=block&id=2978fc6a-fb7e-42ce-95f5-eb9973b30cdc&spaceId=a7846d65-22d0-40b9-9453-328af79b981a&width=860&userId=&cache=v2)

### 테스트 주도 시스템 아키텍처 구축

- 애플리케이션 도메인 논리를 POJO로 작성한다면, 즉 코드 수준에서 아키텍쳐와 분리가 가능하다면 진정한 테스트 주도 아키텍처 구축이 가능하다
- 필요에 따라 새로운 기술을 채택해 단순한 아키텍처를 복잡한 아키텍쳐로 키울 수 있다
- 소프트웨어 구조가 관점을 효과적으로 분리한다면 확장이 가능하다

### 의사 결정을 최적화하라

- 큰 시스템에서는 한 사람이 모든 결정을 내릴 수는 없다
  - 따라서 결정은 최대한 많은 정보가 모일 때까지 미루고 시기가 되었을 경우 해당 파트의 책임자(여기서는 모듈화된 컴포넌트)에게 맡기는 것이 불필요한 고객 피드백과 고통을 덜어줄 것이다

### 명백한 가치가 있을 때 표준을 현명하게 사용하라

- 표준을 사용하면 아이디어와 컴포넌트를 재사용하기 쉽고, 적절한 경험을 가지는 사람을 구하기 쉽고, 좋은 아이디어를 캡슐화하기 쉽고, 컴포넌트를 엮기 쉽다
- 하지만 때로는 표준이 불필요함에도 사용하는 경우가 있다
  - 표준은 확실한 이득을 가져올 경우 사용하라

### 시스템은 도메인 특화 언어가 필요하다

- DSL(Domain Specific Language)이란 간단한 스크립트 언어나 표준 언어로 구현한 API
- 좋은 DSL은 도메인 개념과 그 개념을 구현한 코드 사이에 존재하는 의사소통 간극 낮춘다
- DSL을 사용하면 모든 추상화 수준과 모든 도메인을 POJO로 표현 가능

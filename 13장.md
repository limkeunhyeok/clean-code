# Clean Code

## 13장 동시성

> 다중 스레드 코드는 구현이 어렵다. 각별히 주의해서 깨끗하게 작성해야 한다. SRP를 준수하고, 동시성 오류를 일으키는 잠정적인 원인을 철저히 이해한다. 또, 사용하는 라이브러리와 기본 알고리즘을 이해하고, 보호할 코드 영역을 찾아내는 방법과 특정 코드 영역을 잠그는 방법 이해한다.

### 동시성이 필요한 이유

- 동시성이란 결합을 없애는 전략으로 무엇(what)과 언제(when)를 분리하는 전략이다
- 스레드가 하나인 프로그램은 무엇과 언제가 서로 밀접해있다
- 무엇과 언제를 분리하면(즉, 다중 스레드 이용) 애플리케이션의 구조 효율을 높이고 시스템을 이해하기 쉽고 문제를 분리하기 쉽다
- 동시성 이점
  - 구조적 이점
    - 시스템을 이해하고 문제를 분리하기 쉬움
  - 응답 시관과 작업 처리량을 개선

#### 동시성 관련 미신과 오해

1. 항상 성능을 높여준다.
    
대기 시간이 길어 여러 스레드가 프로세서를 공유할 수 있을 때나, 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높아진다
    
2. 동시성을 구현해도 설계는 변하지 않는다.
    
단일 스레드 시스템 설계 != 다중 스레드의 시스템 설계(언제와 무엇의 분리)
    
3. 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.
    
- 실제 컨데이너의 동작 방법과 동시 수정, 데드락 등을 피하는 방법을 알아야 한다

#### 동시성 관련 타당한 생각

1. 동시성은 다소 부하를 유발한다.
    
- 성능 측면의 부하, 더 많은 코드 요구됨
    
2. 동시성은 복잡하다.
3. 일반적으로 동시성 버그는 재현하기 어렵다.
    
- 일회성 문제로 여겨 무시하기 쉬움
    
4. 동시성을 구현하려면 흔히 근본적인 설계 전략은 재고해야 한다.

### 동시성이 어려운 이유

```java
public class X {
  private int lastIdUsed = 42;

  public int getNextId() {
    return ++lastIdUsed;
  }
}
```

> 위 예시에서 두 개의 스레드가 getNextId()를 동시에 호출한다고 할 때, 우리는 lastIdUsed가 44인 것을 원하지만, 43인 경우가 나올 수 있다

### 동시성 방어 원칙

#### 단일 책임 원칙(SRP)

- 주어진 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다는 원칙
- 동시성은 복잡성 때문에 분리해야 한다
- 동시성 구현 시 고려할 점
  - 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다
  - 동시성 코드에는 다른 코드에서와 다르고 어려운 독자적인 난관이 있다
  - 잘못 구현한 동시성 코드는 여러 방식으로 실패한다. 하나만으로도 어렵다

> 동시성 코드를 다른 코드와 분리하자

#### 따름 정리(corollary): 자료 범위를 제한하라

- 공유 객체를 사용할 때 사용 코드 내에 임계 영역을 키워드로 보호한다
- 임계 영역의 수를 줄인다
- 공유 자료를 수정하는 위치가 많을 때 발생할 수 있는 문제점
  - 보호할 임계 영역을 빼먹어서 공유 자료를 수정하는 모든 코드를 망가뜨림
  - 모든 임계 영역을 올바로 보호했는지 확인하느라 시간과 노력 들어감(DRY 위반을 확인)
  - 버그 찾기 힘듬

> 자료를 캡슐화하고, 공유 자료를 최대한 줄여라

#### 따름 정리: 자료 사본을 사용하라

- 공유 자료를 줄이는 방법
  - 처음부터 공유하지 않는 게 가장 좋다
  - 객체를 복사해 읽기 전용으로 사용한다
  - 각 스레드가 객체를 복사해 사용한 후 한 스레드가 해당 사본에서 결과를 가져온다

#### 따름 정리: 스레드는 가능한 독립적으로 구현하라

- 다른 스레드와 자료를 공유하지 않는 스레드를 구현한다
  - 각 스레드는 클라이언트 요청 하나를 처리하는데, 이때 다른 스레드와 동기화할 필요 없이 모든 정보를 비공유 출처에서 가져오며 로컬 변수에 저장한다

> 독자적인 스레드로, 가능하면 다른 프로세서에서, 돌려도 괞찮도록 자료를 독립적인 단위로 분할하라

### 라이브러리를 이해하라

- 스레드 환경에 안전한 컬렉션을 사용하자
- 일부 클래스 라이브러리는 스레드에 안전하지 못하다

> 언어가 제공하는 클래스를 검토하자

### 실행 모델을 이해하라

|용어|의미|
|:---|:---|
|한정된 자원(Bound Resource)|다중 스레드 환경에서 사용하는 자원으로, 크기나 숫자가 제한적이다. 데이터베이스 연결, 길이가 일정한 읽기/쓰기 버퍼 등이 예다.|
|상호 배제(Mutual Exclusion)|한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우를 가리킨다.|
|기아(Starvation)|한 스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다린다. 예를 들어 항상 짧은 스레드에게 우선순위를 준다면, 짧은 스레드가 지속적으로 이어질 경우, 긴 스레드가 기아 상태에 빠진다.|
|데드락(Deadlcok)|여러 스레드가 서로가 끝나기를 기다린다. 모든 스레드가 각기 필요한 자원을 다른 스레드가 점유하는 바람에 어느 쪽도 더 이상 진행하지 못한다.|
|라이브락(Livelock)|락을 거는 단계에서 각 스레드가 서로 방해한다. 스레드는 계속해서 진행하려 하지만, 공명(reasonance)으로 인해, 굉장히 오랫동안 혹은 영원히 진행하지 못한다.|

#### 생산자-소비자(Producer-Consumer)

- 한정된 자원인 대기열을 사용 
- 생산자 스레드
  - 대기열이 비어있을 때, 정보를 생성해 buffer나 queue에 넣는다 
  - 정보를 채운 다음 소비자 스레드에 "대기열에 정보가 있다"는 시그널 보낸다
- 소비자 스레드
  - 대기열에 정보가 있을 때, 대기열에서 정보를 가져와 사용한다
  - 정보를 읽어들인 후 "대기열에 정보가 있다"는 시그널을 보낸다
- 둘 다 진행 가능함에도 불구하고 동시에 서로에게서 시그널을 기다릴 가능성이 존재

#### 읽기-쓰기(Readers-Writers)

- 읽기 스레드(독자)를 위한 주된 정보원으로 공유 자원을 사용하지만, 쓰기 스레드(저자)가 이 공유 자원을 이따금 갱신한다
  - 처리율 문제(균형 잡기 힘듦)
    1. 처리율 강조(독자 우선권) 시 읽기 스레드가 계속 되는 경우 쓰기 스레드는 기아 상태에 빠지거나 오래된 정보 쌓인다
    2. 쓰기 스레드 우선권 갖을(저자 우선권) 시 처리율 낮아진다
- 양쪽 균형을 잡으면서 갱신 문제를 피하는 해법이 필요

#### 식사하는 철학자들(Dining Philosophers)

- 가운데에 스파게티 한 접시가 놓여있는 둥근 식탁에 철학자들이 둘러 앉아 있고, 각 철학자들 왼편에는 포크 놓여있다
  - 각 철학자는 배가 고프지 않으면 생각하며 시간 보낸다
  - 배가 고프면 양손에 포크를 쥐고 스파게티를 먹는다(좌우의 철학자 중 한 명이라도 포크를 사용하는 중이라면 먹지 못함)
- 철학자 = 스레드, 포크 = 자원이라고 생각하면 자원을 놓고 경쟁하는 프로세스와 비슷한 문제 상황
- 잘 설계되지 않은 시스템은 데드락, 라이브락, 처리율 저하, 효율성 저하 등을 겪는다

### 동기화하는 메서드 사이에 존재하는 의존성을 이해하라

- 동기화하는 메서드 사이에 의존성이 존재하면 동시성 코드에 찾기 힘든 버그 생긴다(자바에서는 개별 메서드 보호하는 synchronized 지원)
  - 공유 객체 하나에는 메서드 하나만 사용하자
- 공유 객체 하나에 여러 메서드가 필요할 때 고려할 방법 3가지

1. **클라이언트에서 잠금**
        
- 클라이언트에서 첫번째 메서드를 호출하기 전에 서버를 잠그고, 마지막 메서드 호출까지 잠금 유지
  - 공유 객체를 사용하는 코드에서 공유 객체를 잠그는 것이다
     
2. **서버에서 잠금** 
        
- 서버에다 '서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는' 메서드를 구현하고, 클라이언트가 이 메서드 호출
  - 공유 객체에 새로운 메서드를 작성하고 잠금이 필요한 동작 전체를 수행하게 하는 것이다.
        
3. **연결(Adapted) 서버** 
        
- 잠금을 수행하는 중간 단계를 생성
- '서버에서 잠금' 방식과 유사하지만 원래 서버는 변경 X

### 동기화하는 부분을 작게 만들어라

- 자바에서 synchronized 키워드를 사용하면 락을 설정하여 임계 영역을 보호한다
  - 락으로 감싼 코드는 한 번에 한 스레드만 실행이 가능하므로 전체적으로는 스레드를 지연시키고 부하를 가중시킨다
    - synchronized 남용 X
    - 하지만 임계 영역 수를 줄이고자 필요 이상으로 큰 임계 영역을 만들면 스레드 간에 경쟁이 늘어나고 프로그램 성능도 떨어진다
- 동기화하는 부분을 최대한 작게 만들자

### 올바른 코드 종료는 구현하기 어렵다

- 영구적으로 돌아가는 시스템 구현 방법 != 잠시 돌다가 종료하는 시스템을 구현하는 방법
- 깔끔하게 종료하는 시스템 구현은 어렵다
  - 데드락 위험
- 종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현하자, 생각보다 오래 걸리고 생각보다 어려우므로 이미 나온 알고리즘 검토하면 도움된다

### 스레드 코드 테스트하기

- 문제를 노출하는 테스트 케이스를 작성하자
- 프로그램 설정과 시스템 설정과 부하를 바꿔가며 자주 돌리자
- 테스트가 실패하면 원인을 추적하자
- 다시 돌렸더니 통과하더라도 그냥 넘어가면 X

#### 다중 스레드 사용 시 고려할 점

1. 말이 안 되는 실패는 잠점적인 스레드 문제로 취급하라

- 시스템 실패를 '일회성'이라 치부하지 마라
    
2. 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자

- 스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅하지 마라
- 먼저 스레드 환경 밖에서 코드를 올바로 돌려라

3. 다중 스레드를 쓰는 코드 부분을 다양한 환경에 끼워 넣을 수 있게 스레드 코드를 구현하라

- 다양한 설정에서 실행할 목적으로 다른 환경에 쉽게 끼워 넣을 수 있게 코드를 구현하라

4. 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라
5. 프로세서 수보다 많은 스레드를 돌려보라
6. 다른 플랫폼에서 돌려보라

- 처음부터 그리고 자주 모든 목표 플랫폼에서 코드를 돌려라

7. 코드에 보조 코드(instrument)를 넣어 돌려라 강제로 실패를 일으키게 해보라

- 흔들기 기법을 사용해 오류를 찾아내라

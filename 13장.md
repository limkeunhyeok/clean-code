# Clean Code

## 13장 동시성

> 다중 스레드 코드는 구현이 어렵다. 각별히 주의해서 깨끗하게 작성해야 한다. SRP를 준수하고, 동시성 오류를 일으키는 잠정적인 원인을 철저히 이해한다. 또, 사용하는 라이브러리와 기본 알고리즘을 이해하고, 보호할 코드 영역을 찾아내는 방법과 특정 코드 영역을 잠그는 방법 이해한다.

### 동시성이 필요한 이유

- 동시성이란 결합을 없애는 전략으로 무엇(what)과 언제(when)를 분리하는 전략이다
- 스레드가 하나인 프로그램은 무엇과 언제가 서로 밀접해있다
- 무엇과 언제를 분리하면(즉, 다중 스레드 이용) 애플리케이션의 구조 효율을 높이고 시스템을 이해하기 쉽고 문제를 분리하기 쉽다
- 동시성 이점
  - 구조적 이점
    - 시스템을 이해하고 문제를 분리하기 쉬움
  - 응답 시관과 작업 처리량을 개선

#### 동시성 관련 미신과 오해

1. 항상 성능을 높여준다.
    
대기 시간이 길어 여러 스레드가 프로세서를 공유할 수 있을 때나, 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높아진다
    
2. 동시성을 구현해도 설계는 변하지 않는다.
    
단일 스레드 시스템 설계 != 다중 스레드의 시스템 설계(언제와 무엇의 분리)
    
3. 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.
    
- 실제 컨데이너의 동작 방법과 동시 수정, 데드락 등을 피하는 방법을 알아야 한다

#### 동시성 관련 타당한 생각

1. 동시성은 다소 부하를 유발한다.
    
- 성능 측면의 부하, 더 많은 코드 요구됨
    
2. 동시성은 복잡하다.
3. 일반적으로 동시성 버그는 재현하기 어렵다.
    
- 일회성 문제로 여겨 무시하기 쉬움
    
4. 동시성을 구현하려면 흔히 근본적인 설계 전략은 재고해야 한다.

### 동시성이 어려운 이유

```java
public class X {
  private int lastIdUsed = 42;

  public int getNextId() {
    return ++lastIdUsed;
  }
}
```

> 위 예시에서 두 개의 스레드가 getNextId()를 동시에 호출한다고 할 때, 우리는 lastIdUsed가 44인 것을 원하지만, 43인 경우가 나올 수 있다

### 동시성 방어 원칙

#### 단일 책임 원칙(SRP)

- 주어진 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다는 원칙
- 동시성은 복잡성 때문에 분리해야 한다
- 동시성 구현 시 고려할 점
  - 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다
  - 동시성 코드에는 다른 코드에서와 다르고 어려운 독자적인 난관이 있다
  - 잘못 구현한 동시성 코드는 여러 방식으로 실패한다. 하나만으로도 어렵다

> 동시성 코드를 다른 코드와 분리하자

#### 따름 정리(corollary): 자료 범위를 제한하라

- 공유 객체를 사용할 때 사용 코드 내에 임계 영역을 키워드로 보호한다
- 임계 영역의 수를 줄인다
- 공유 자료를 수정하는 위치가 많을 때 발생할 수 있는 문제점
  - 보호할 임계 영역을 빼먹어서 공유 자료를 수정하는 모든 코드를 망가뜨림
  - 모든 임계 영역을 올바로 보호했는지 확인하느라 시간과 노력 들어감(DRY 위반을 확인)
  - 버그 찾기 힘듬

> 자료를 캡슐화하고, 공유 자료를 최대한 줄여라

#### 따름 정리: 자료 사본을 사용하라

- 공유 자료를 줄이는 방법
  - 처음부터 공유하지 않는 게 가장 좋다
  - 객체를 복사해 읽기 전용으로 사용한다
  - 각 스레드가 객체를 복사해 사용한 후 한 스레드가 해당 사본에서 결과를 가져온다

#### 따름 정리: 스레드는 가능한 독립적으로 구현하라

- 다른 스레드와 자료를 공유하지 않는 스레드를 구현한다
  - 각 스레드는 클라이언트 요청 하나를 처리하는데, 이때 다른 스레드와 동기화할 필요 없이 모든 정보를 비공유 출처에서 가져오며 로컬 변수에 저장한다

> 독자적인 스레드로, 가능하면 다른 프로세서에서, 돌려도 괞찮도록 자료를 독립적인 단위로 분할하라

### 라이브러리를 이해하라

- 스레드 환경에 안전한 컬렉션을 사용하자
- 일부 클래스 라이브러리는 스레드에 안전하지 못하다

> 언어가 제공하는 클래스를 검토하자

### 실행 모델을 이해하라

|용어|의미|
|:---|:---|
|한정된 자원(Bound Resource)|다중 스레드 환경에서 사용하는 자원으로, 크기나 숫자가 제한적이다. 데이터베이스 연결, 길이가 일정한 읽기/쓰기 버퍼 등이 예다.|
|상호 배제(Mutual Exclusion)|한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우를 가리킨다.|
|기아(Starvation)|한 스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다린다. 예를 들어 항상 짧은 스레드에게 우선순위를 준다면, 짧은 스레드가 지속적으로 이어질 경우, 긴 스레드가 기아 상태에 빠진다.|
|데드락(Deadlcok)|여러 스레드가 서로가 끝나기를 기다린다. 모든 스레드가 각기 필요한 자원을 다른 스레드가 점유하는 바람에 어느 쪽도 더 이상 진행하지 못한다.|
|라이브락(Livelock)|락을 거는 단계에서 각 스레드가 서로 방해한다. 스레드는 계속해서 진행하려 하지만, 공명(reasonance)으로 인해, 굉장히 오랫동안 혹은 영원히 진행하지 못한다.|
